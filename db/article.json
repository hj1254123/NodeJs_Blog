[{"title":"jq选择器","time":1539484051,"intro":"一篇jq的笔记，嘟嘟嘟","content":"## 基本选择器\n\n| 名称       | 用法               | 描述                                 |\n| ---------- | ------------------ | :----------------------------------- |\n| ID选择器   | $(“#id”);          | 获取指定ID的元素                     |\n| 类选择器   | $(“.class”);       | 获取同一类class的元素                |\n| 标签选择器 | $(“div”);          | 获取同一类标签的所有元素             |\n| 并集选择器 | $(“div,p,li”);     | 使用逗号分隔，只要符合条件之一就可。 |\n| 交集选择器 | $(“div.redClass”); | 获取class为redClass的div元素         |\n\n> 总结：跟css的选择器用法一模一样。\n\n\n\n## 层级选择器\n\n| 名称       | 用法        | 描述                                                        |\n| ---------- | ----------- | :---------------------------------------------------------- |\n| 子代选择器 | $(“ul>li”); | 使用>号，获取儿子层级的元素，注意，并不会获取孙子层级的元素 |\n| 后代选择器 | $(“ul li”); | 使用空格，代表后代选择器，获取ul下的所有li元素，包括孙子等  |\n\n\n\n> 跟CSS的选择器一模一样。\n\n## 过滤选择器\n\n> 这类选择器都带冒号:\n\n| 名称         | 用法                               | 描述                                                        |\n| ------------ | ---------------------------------- | :---------------------------------------------------------- |\n| :eq（index） | $(“li:eq(2)”).css(“color”, ”red”); | 获取到的li元素中，选择索引号为2的元素，索引号index从0开始。 |\n| :odd         | $(“li:odd”).css(“color”, ”red”);   | 获取到的li元素中，选择索引号为奇数的元素                    |\n| :even        | $(“li:even”).css(“color”, ”red”);  | 获取到的li元素中，选择索引号为偶数的元素                    |\n\n\n## 筛选选择器(方法)\n\n> 筛选选择器的功能与过滤选择器有点类似，但是用法不一样，筛选选择器主要是方法。\n\n| 名称               | 用法                        | 描述                             |\n| ------------------ | --------------------------- | :------------------------------- |\n| children(selector) | $(“ul”).children(“li”)      | 相当于$(“ul>li”)，子类选择器     |\n| find(selector)     | $(“ul”).find(“li”);         | 相当于$(“ul li”),后代选择器      |\n| siblings(selector) | $(“#first”).siblings(“li”); | 查找兄弟节点，不包括自己本身。   |\n| parent()           | $(“#first”).parent();       | 查找父亲                         |\n| eq(index)          | $(“li”).eq(2);              | 相当于$(“li:eq(2)”),index从0开始 |\n| next()             | $(“li”).next()              | 找下一个兄弟                     |\n| prev()             | $(“li”).prev()              | 找上一次兄弟                     |","id":2},{"title":"FlexBox","time":1539872146,"intro":"阮一峰教程理论篇","content":"阮一峰[FLexBox 语法篇](http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html)\n\n------\n\n## 一、Flex布局是什么\n\n- 任何一个容器都可以指定为Flex布局\n\n  ```\n  .box {\n      display: flex;\n  }\n  ```\n\n- 行内元素也可以使用 Flex 布局\n\n  ```\n  .box {\n      display: inine-flex;\n  }\n  ```\n\n- Webkit 内核的浏览器，必须加上`-webkit`前缀\n\n  ```\n  .box{\n    display: -webkit-flex; /* Safari */\n    display: flex;\n  }\n  ```\n\n## 二、 基本概念\n\n- 采用 Flex 布局的元素，称为 Flex 容器（flex container），简称\"**容器**\"。\n- 它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称\"**项目**\"。\n\n![img](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071004.png)\n\n容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis）。主轴的开始位置（与边框的交叉点）叫做`main start`，结束位置叫做`main end`；交叉轴的开始位置叫做`cross start`，结束位置叫做`cross end`。\n\n项目默认沿主轴排列。单个项目占据的主轴空间叫做`main size`，占据的交叉轴空间叫做`cross size`。\n\n## 三、容器的属性\n\n以下6个属性设置在容器上。\n\n> - flex-direction (主轴方向)\n> - flex-wrap (轴线放不下如何换行)\n> - flex-flow (上两个的简写)\n> - justify-content (在主轴上的对齐方式)\n> - align-items (在交叉轴上如何对齐。)\n> - align-content (多根轴线的对齐方式)\n\n### 3.1 flex-direction属性(主轴方向)\n\n`flex-direction`属性决定主轴的方向（即项目的排列方向）。\n\n> ```\n> .box {\n>   flex-direction: row | row-reverse | column | column-reverse;\n> }\n> ```\n\n![img](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071005.png)\n\n它可能有4个值。\n\n> - `row`（默认值）：主轴为水平方向，起点在左端。\n> - `row-reverse`：主轴为水平方向，起点在右端。\n> - `column`：主轴为垂直方向，起点在上沿。\n> - `column-reverse`：主轴为垂直方向，起点在下沿。\n\n### 3.2 flex-wrap属性 (是否换行)\n\n默认情况下，项目都排在一条线（又称\"轴线\"）上。`flex-wrap`属性定义，如果一条轴线排不下，如何换行。\n\n![img](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071006.png)\n\n> ```\n> .box{\n>   flex-wrap: nowrap | wrap | wrap-reverse;\n> }\n> ```\n\n它可能取三个值。\n\n（1）`nowrap`（默认）：不换行。\n\n![img](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071007.png)\n\n（2）`wrap`：换行，第一行在上方。\n\n![img](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071008.jpg)\n\n（3）`wrap-reverse`：换行，第一行在下方。\n\n![img](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071009.jpg)\n\n### 3.3 flex-flow (简写)\n\n`flex-flow`属性是`flex-direction`属性和`flex-wrap`属性的简写形式，默认值为`row nowrap`。\n\n> ```\n> .box {\n>   flex-flow: <flex-direction> || <flex-wrap>;\n> }\n> ```\n\n### 3.4 justify-content属性(主轴对齐方式)\n\n`justify-content`属性定义了项目在主轴上的对齐方式。\n\n> ```\n> .box {\n>   justify-content: flex-start | flex-end | center | space-between | space-around;\n> }\n> ```\n\n![img](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071010.png)\n\n它可能取5个值，具体对齐方式与轴的方向有关。下面假设主轴为从左到右。\n\n> - `flex-start`（默认值）：左对齐\n> - `flex-end`：右对齐\n> - `center`： 居中\n> - `space-between`：两端对齐，项目之间的间隔都相等。\n> - `space-around`：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。\n\n### 3.5 align-items属性 (交叉轴对齐方式)\n\n`align-items`属性定义项目在交叉轴上如何对齐。\n\n> ```\n> .box {\n>   align-items: flex-start | flex-end | center | baseline | stretch;\n> }\n> ```\n\n![img](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071011.png)\n\n它可能取5个值。具体的对齐方式与交叉轴的方向有关，下面假设交叉轴从上到下。\n\n> - `flex-start`：交叉轴的起点对齐。\n> - `flex-end`：交叉轴的终点对齐。\n> - `center`：交叉轴的中点对齐。\n> - `baseline`: 项目的第一行文字的基线对齐。\n> - `stretch`（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。\n\n### 3.6 align-content属性(多根轴线对其方式)\n\n`align-content`属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。\n\n> ```\n> .box {\n>   align-content: flex-start | flex-end | center | space-between | space-around | stretch;\n> }\n> ```\n\n![img](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071012.png)\n\n该属性可能取6个值。\n\n> - `flex-start`：与交叉轴的起点对齐。\n> - `flex-end`：与交叉轴的终点对齐。\n> - `center`：与交叉轴的中点对齐。\n> - `space-between`：与交叉轴两端对齐，轴线之间的间隔平均分布。\n> - `space-around`：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。\n> - `stretch`（默认值）：轴线占满整个交叉轴。\n\n## 四、项目的属性\n\n以下6个属性设置在项目上。\n\n> - `order` (项目的排列顺序)\n> - `flex-grow` (定义项目的放大比例)\n> - `flex-shrink` (定义了项目的缩小比例)\n> - `flex-basis` (定义了在分配多余空间之前，项目占据的主轴空间)\n> - `flex` (上面3个的简写)\n> - `align-self` (允许单个项目有与其他项目不一样的对齐方式，可覆盖`align-items`属性，与align-items一致)\n\n### 4.1 order属性(项目排列顺序)\n\n`order`属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。\n\n> ```\n> .item {\n>   order: <integer>;\n> }\n> ```\n\n![img](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071013.png)\n\n### 4.2 flex-grow属性(项目放大比例)\n\n`flex-grow`属性定义项目的放大比例，默认为`0`，即如果存在剩余空间，也不放大。\n\n> ```\n> .item {\n>   flex-grow: <number>; /* default 0 */\n> }\n> ```\n\n![img](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071014.png)\n\n如果所有项目的`flex-grow`属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的`flex-grow`属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。\n\n### 4.3 flex-shrink属性(项目缩小比例)\n\n`flex-shrink`属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。\n\n> ```\n> .item {\n>   flex-shrink: <number>; /* default 1 */\n> }\n> ```\n\n![img](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071015.jpg)\n\n如果所有项目的`flex-shrink`属性都为1，当空间不足时，都将等比例缩小。如果一个项目的`flex-shrink`属性为0，其他项目都为1，则空间不足时，前者不缩小。\n\n负值对该属性无效。\n\n### 4.4 flex-basis属性(主轴长)\n\n`flex-basis`属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为`auto`，即项目的本来大小。\n\n> ```\n> .item {\n>   flex-basis: <length> | auto; /* default auto */\n> }\n> ```\n\n它可以设为跟`width`或`height`属性一样的值（比如350px），则项目将占据固定空间。\n\n### 4.5 flex属性(简写·优先写这个)\n\n`flex`属性是`flex-grow`, `flex-shrink` 和 `flex-basis`的简写，默认值为`0 1 auto`。后两个属性可选。\n\n> ```\n> .item {\n>   flex: none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]\n> }\n> ```\n\n该属性有两个快捷值：`auto` (`1 1 auto`) 和 none (`0 0 auto`)。\n\n建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。\n\n### 4.6 align-self属性(剥离单个项目，交叉轴对其方式)\n\n`align-self`属性允许单个项目有与其他项目不一样的对齐方式，可覆盖`align-items`属性。默认值为`auto`，表示继承父元素的`align-items`属性，如果没有父元素，则等同于`stretch`。\n\n> ```\n> .item {\n>   align-self: auto | flex-start | flex-end | center | baseline | stretch;\n> }\n> ```\n\n![img](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071016.png)\n\n该属性可能取6个值，除了auto，其他都与align-items属性完全一致。","id":3},{"title":"FlexBox实例","time":1539872212,"intro":"实例篇","content":"## 一、骰子的布局\n\n骰子的一面，最多可以放置9个点。\n\n![img](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071328.png)\n\n下面，就来看看Flex如何实现，从1个点到9个点的布局。你可以到[codepen](http://codepen.io/LandonSchropp/pen/KpzzGo)查看Demo。\n\n![img](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071329.png)\n\n如果不加说明，本节的HTML模板一律如下。\n\n> ```\n> <div class=\"box\">\n>   <span class=\"item\"></span>\n> </div>\n> ```\n\n上面代码中，div元素（代表骰子的一个面）是Flex容器，span元素（代表一个点）是Flex项目。如果有多个项目，就要添加多个span元素，以此类推。\n\n### 1.1 单项目\n\n首先，只有左上角1个点的情况。Flex布局默认就是首行左对齐，所以一行代码就够了。\n\n![img](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071301.png)\n\n> ```\n> .box {\n>   display: flex;\n> }\n> ```\n\n设置项目的对齐方式，就能实现居中对齐和右对齐。\n\n![img](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071302.png)\n\n> ```\n> .box {\n>   display: flex;\n>   justify-content: center;\n> }\n> ```\n\n![img](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071303.png)\n\n> ```\n> .box {\n>   display: flex;\n>   justify-content: flex-end;\n> }\n> ```\n\n设置交叉轴对齐方式，可以垂直移动主轴。\n\n![img](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071304.png)\n\n> ```\n> .box {\n>   display: flex;\n>   align-items: center;\n> }\n> ```\n\n![img](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071305.png)\n\n> ```\n> .box {\n>   display: flex;\n>   justify-content: center;\n>   align-items: center;\n> }\n> ```\n\n![img](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071306.png)\n\n> ```\n> .box {\n>   display: flex;\n>   justify-content: center;\n>   align-items: flex-end;\n> }\n> ```\n\n![img](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071307.png)\n\n> ```\n> .box {\n>   display: flex;\n>   justify-content: flex-end;\n>   align-items: flex-end;\n> }\n> ```\n\n### 1.2 双项目\n\n![img](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071308.png)\n\n> ```\n> .box {\n>   display: flex;\n>   justify-content: space-between;\n> }\n> ```\n\n![img](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071309.png)\n\n> ```\n> .box {\n>   display: flex;\n>   flex-direction: column;\n>   justify-content: space-between;\n> }\n> ```\n\n![img](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071310.png)\n\n> ```\n> .box {\n>   display: flex;\n>   flex-direction: column;\n>   justify-content: space-between;\n>   align-items: center;\n> }\n> ```\n\n![img](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071311.png)\n\n> ```\n> .box {\n>   display: flex;\n>   flex-direction: column;\n>   justify-content: space-between;\n>   align-items: flex-end;\n> }\n> ```\n\n![img](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071312.png)\n\n> ```\n> .box {\n>   display: flex;\n> }\n> \n> .item:nth-child(2) {\n>   align-self: center;\n> }\n> ```\n\n![img](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071313.png)\n\n> ```\n> .box {\n>   display: flex;\n>   justify-content: space-between;\n> }\n> \n> .item:nth-child(2) {\n>   align-self: flex-end;\n> }\n> ```\n\n### 1.3 三项目\n\n![img](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071314.png)\n\n> ```\n> .box {\n>   display: flex;\n> }\n> \n> .item:nth-child(2) {\n>   align-self: center;\n> }\n> \n> .item:nth-child(3) {\n>   align-self: flex-end;\n> }\n> ```\n\n### 1.4 四项目\n\n![img](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071315.png)\n\n> ```\n> .box {\n>   display: flex;\n>   flex-wrap: wrap;\n>   justify-content: flex-end;\n>   align-content: space-between;\n> }\n> ```\n\n![img](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071316.png)\n\nHTML代码如下。\n\n> ```\n> <div class=\"box\">\n>   <div class=\"column\">\n>     <span class=\"item\"></span>\n>     <span class=\"item\"></span>\n>   </div>\n>   <div class=\"column\">\n>     <span class=\"item\"></span>\n>     <span class=\"item\"></span>\n>   </div>\n> </div>\n> ```\n\nCSS代码如下。\n\n> ```\n> .box {\n>   display: flex;\n>   flex-wrap: wrap;\n>   align-content: space-between;\n> }\n> \n> .column {\n>   flex-basis: 100%;\n>   display: flex;\n>   justify-content: space-between;\n> }\n> ```\n\n### 1.5 六项目\n\n![img](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071317.png)\n\n> ```\n> .box {\n>   display: flex;\n>   flex-wrap: wrap;\n>   align-content: space-between;\n> }\n> ```\n\n![img](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071318.png)\n\n> ```\n> .box {\n>   display: flex;\n>   flex-direction: column;\n>   flex-wrap: wrap;\n>   align-content: space-between;\n> }\n> ```\n\n![img](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071319.png)\n\nHTML代码如下。\n\n> ```\n> <div class=\"box\">\n>   <div class=\"row\">\n>     <span class=\"item\"></span>\n>     <span class=\"item\"></span>\n>     <span class=\"item\"></span>\n>   </div>\n>   <div class=\"row\">\n>     <span class=\"item\"></span>\n>   </div>\n>   <div class=\"row\">\n>      <span class=\"item\"></span>\n>      <span class=\"item\"></span>\n>   </div>\n> </div>\n> ```\n\nCSS代码如下。\n\n> ```\n> .box {\n>   display: flex;\n>   flex-wrap: wrap;\n> }\n> \n> .row{\n>   flex-basis: 100%;\n>   display:flex;\n> }\n> \n> .row:nth-child(2){\n>   justify-content: center;\n> }\n> \n> .row:nth-child(3){\n>   justify-content: space-between;\n> }\n> ```\n\n### 1.6 九项目\n\n![img](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071320.png)\n\n> ```\n> .box {\n>   display: flex;\n>   flex-wrap: wrap;\n> }\n> ```\n\n## 二、网格布局\n\n### 2.1 基本网格布局\n\n最简单的网格布局，就是平均分布。在容器里面平均分配空间，跟上面的骰子布局很像，但是需要设置项目的自动缩放。\n\n![img](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071321.png)\n\nHTML代码如下。\n\n> ```\n> <div class=\"Grid\">\n>   <div class=\"Grid-cell\">...</div>\n>   <div class=\"Grid-cell\">...</div>\n>   <div class=\"Grid-cell\">...</div>\n> </div>\n> ```\n\nCSS代码如下。\n\n> ```\n> .Grid {\n>   display: flex;\n> }\n> \n> .Grid-cell {\n>   flex: 1;\n> }\n> ```\n\n### 2.2 百分比布局\n\n某个网格的宽度为固定的百分比，其余网格平均分配剩余的空间。\n\n![img](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071322.png)\n\nHTML代码如下。\n\n> ```\n> <div class=\"Grid\">\n>   <div class=\"Grid-cell u-1of4\">...</div>\n>   <div class=\"Grid-cell\">...</div>\n>   <div class=\"Grid-cell u-1of3\">...</div>\n> </div>\n> ```\n\n> ```\n> .Grid {\n>   display: flex;\n> }\n> \n> .Grid-cell {\n>   flex: 1;\n> }\n> \n> .Grid-cell.u-full {\n>   flex: 0 0 100%;\n> }\n> \n> .Grid-cell.u-1of2 {\n>   flex: 0 0 50%;\n> }\n> \n> .Grid-cell.u-1of3 {\n>   flex: 0 0 33.3333%;\n> }\n> \n> .Grid-cell.u-1of4 {\n>   flex: 0 0 25%;\n> }\n> ```\n\n## 三、圣杯布局\n\n[圣杯布局](https://en.wikipedia.org/wiki/Holy_Grail_(web_design))（Holy Grail Layout）指的是一种最常见的网站布局。页面从上到下，分成三个部分：头部（header），躯干（body），尾部（footer）。其中躯干又水平分成三栏，从左到右为：导航、主栏、副栏。\n\n![img](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071323.png)\n\nHTML代码如下。\n\n> ```\n> <body class=\"HolyGrail\">\n>   <header>...</header>\n>   <div class=\"HolyGrail-body\">\n>     <main class=\"HolyGrail-content\">...</main>\n>     <nav class=\"HolyGrail-nav\">...</nav>\n>     <aside class=\"HolyGrail-ads\">...</aside>\n>   </div>\n>   <footer>...</footer>\n> </body>\n> ```\n\nCSS代码如下。\n\n> ```\n> .HolyGrail {\n>   display: flex;\n>   min-height: 100vh;\n>   flex-direction: column;\n> }\n> \n> header,\n> footer {\n>   flex: 1;\n> }\n> \n> .HolyGrail-body {\n>   display: flex;\n>   flex: 1;\n> }\n> \n> .HolyGrail-content {\n>   flex: 1;\n> }\n> \n> .HolyGrail-nav, .HolyGrail-ads {\n>   /* 两个边栏的宽度设为12em */\n>   flex: 0 0 12em;\n> }\n> \n> .HolyGrail-nav {\n>   /* 导航放到最左边 */\n>   order: -1;\n> }\n> ```\n\n如果是小屏幕，躯干的三栏自动变为垂直叠加。\n\n> ```\n> @media (max-width: 768px) {\n>   .HolyGrail-body {\n>     flex-direction: column;\n>     flex: 1;\n>   }\n>   .HolyGrail-nav,\n>   .HolyGrail-ads,\n>   .HolyGrail-content {\n>     flex: auto;\n>   }\n> }\n> ```\n\n## 四、输入框的布局\n\n我们常常需要在输入框的前方添加提示，后方添加按钮。\n\n![img](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071324.png)\n\nHTML代码如下。\n\n> ```\n> <div class=\"InputAddOn\">\n>   <span class=\"InputAddOn-item\">...</span>\n>   <input class=\"InputAddOn-field\">\n>   <button class=\"InputAddOn-item\">...</button>\n> </div>\n> \n> ```\n\nCSS代码如下。\n\n> ```\n> .InputAddOn {\n>   display: flex;\n> }\n> \n> .InputAddOn-field {\n>   flex: 1;\n> }\n> \n> ```\n\n## 五、悬挂式布局\n\n有时，主栏的左侧或右侧，需要添加一个图片栏。\n\n![img](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071325.png)\n\nHTML代码如下。\n\n> ```\n> <div class=\"Media\">\n>   <img class=\"Media-figure\" src=\"\" alt=\"\">\n>   <p class=\"Media-body\">...</p>\n> </div>\n> \n> ```\n\nCSS代码如下。\n\n> ```\n> .Media {\n>   display: flex;\n>   align-items: flex-start;\n> }\n> \n> .Media-figure {\n>   margin-right: 1em;\n> }\n> \n> .Media-body {\n>   flex: 1;\n> }\n> \n> ```\n\n## 六、固定的底栏\n\n有时，页面内容太少，无法占满一屏的高度，底栏就会抬高到页面的中间。这时可以采用Flex布局，让底栏总是出现在页面的底部。\n\n![img](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071326.png)\n\nHTML代码如下。\n\n> ```\n> <body class=\"Site\">\n>   <header>...</header>\n>   <main class=\"Site-content\">...</main>\n>   <footer>...</footer>\n> </body>\n> \n> ```\n\nCSS代码如下。\n\n> ```\n> .Site {\n>   display: flex;\n>   min-height: 100vh;\n>   flex-direction: column;\n> }\n> \n> .Site-content {\n>   flex: 1;\n> }\n> \n> ```\n\n## 七，流式布局\n\n每行的项目数固定，会自动分行。\n\n![img](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071330.png)\n\nCSS的写法。\n\n> ```\n> .parent {\n>   width: 200px;\n>   height: 150px;\n>   background-color: black;\n>   display: flex;\n>   flex-flow: row wrap;\n>   align-content: flex-start;\n> }\n> \n> .child {\n>   box-sizing: border-box;\n>   background-color: white;\n>   flex: 0 0 25%;\n>   height: 50px;\n>   border: 1px solid red;\n> }\n> \n> ```\n\n（完）","id":4},{"title":"自适应的网页设计","time":1539961904,"intro":"JS多绿付快快快快快快快快快快快快快快快快快快快快扩JS多绿付快快快快快快快快快快快快快快快快快快快快扩JS多绿付快快快快快快快快快快快快快快快快快快快快扩JS多绿付快快快快快快快快快快快快快快快快快快快快扩","content":"### 0.原文\n\n[阮一峰文章](http://www.ruanyifeng.com/blog/2012/05/responsive_web_design.html)\n\n### 1.标准套路\n\n```html\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no\">\n```\n\n### 2.不使用绝对宽度\n\n#### css不使用像素宽度\n\n`width: xxx px;`\n\n只使用百分比宽度\n\n`width: xx%;`\n\n或者\n\n`width: auto;`\n\n#### **相对大小的字体**\n\n字体也不能使用绝对大小（px），而只能使用相对大小（em）。\n\n```css\n　　body {\n　　　　font: normal 100% Helvetica, Arial, sans-serif;\n　　}\n\n```\n\n上面的代码指定，字体大小是页面默认大小的100%，即16像素。\n\n```css\n　　h1 {\n\n　　　　font-size: 1.5em; \n\n　　}\n\n```\n\n然后，h1的大小是默认大小的1.5倍，即24像素（24/16=1.5）。\n\n```css\n　　small {\n\n　　　　font-size: 0.875em;\n\n　　}\n\n```\n\nsmall元素的大小是默认大小的0.875倍，即14像素（14/16=0.875）\n\n\n\n### 3.自适应网页“核心”\n\n根据条件，加载不同css文件\n\n#### 方式一，HTML中：\n\n```html\n<!-- 在设备为屏幕 and 最大宽度为400px(也就是小于400px)时，加载one.css  -->\n\n<link\n\trel=\"stylesheet\" type=\"text/css\"\n\tmedia=\"screen and (max-width: 400px)\"      \n\thref=\"one.css\"\n>\n\n<!-- 设备为屏幕 and 最小宽度为400px and 最大宽度为600px(400~600之间)时,加载two.css -->\n<link\n\trel=\"stylesheet\" type=\"text/css\"\n\tmedia=\"screen and (min-width: 400px) and (max-width: 600px)\"\n\thref=\"smallScreen.css\"\n>\n\n```\n\n#### 方式二，css中：\n\n```css\n@import url(\"one.css\") screen and (max-device-width: 400px);\n```\n\n### 4.css中@media规则\n\n同一个css文件中，也可以\n\n```css\n/*宽度小于400px时，设置对应样式*/\n@media screen and (max-width: 400px) {\n\n    .column {\n      float: none;\n      width:auto;\n    }\n\n    #sidebar {\n      display:none;\n    }\n\n}\n```\n\n### 5.图片自适应\n\n```css\nimg { max-width: 100%}\n```\n\n这行代码对于大多数嵌入网页的视频也有效，所以可以写成：\n\n```css\nimg, object { max-width: 100%;}\n```\n\n不过，有条件的话，最好还是根据不同大小的屏幕，加载不同分辨率的图片。有[很多方法](http://blog.cloudfour.com/responsive-imgs-part-2/)可以做到这一条，服务器端和客户端都可以实现。 ","id":5},{"title":"php配置笔记","time":1540512640,"intro":"学习php时的笔记，测试用...","content":"### 配置扩展模块\n\n1. 打开php里有一个ext目录，里面存放了许多需要载入才能用的模块\n2. 打开php目录，复制一份`php.ini-development`文件，修改为`php.ini`\n3. 打开`php.ini`文件，修改`; extension_dir = \"ext\"`,为`extension_dir = \"<路径>/ext\"`ext文件夹的地址\n4. 往下拉，有一坨`;extension=bz2;extension=curl等等`，解开相应模块前的`;`即可\n5. 把Apache重启一下\n6. 然而还是不行，因为`php.ini`默认配置路径在`c:/windows`里，需要修改。(可以用`phpinfo()`函数打印出配置信息)\n7. 打开Apache的`httpd.conf`文件，在`LoadModule php7_module C:/php/php7apache2_4.dll`，上一行加上`PHPIniDir C:/php`,重启\n\n### 启动调试功能\n\n> CMD切换到php目录，输入命令`php -a`即可\n\n","id":9},{"title":"jquery","time":1540627959,"intro":"测试","content":"## 基本选择器\n\n| 名称       | 用法               | 描述                                 |\n| ---------- | ------------------ | :----------------------------------- |\n| ID选择器   | $(“#id”);          | 获取指定ID的元素                     |\n| 类选择器   | $(“.class”);       | 获取同一类class的元素                |\n| 标签选择器 | $(“div”);          | 获取同一类标签的所有元素             |\n| 并集选择器 | $(“div,p,li”);     | 使用逗号分隔，只要符合条件之一就可。 |\n| 交集选择器 | $(“div.redClass”); | 获取class为redClass的div元素         |\n\n> 总结：跟css的选择器用法一模一样。\n\n\n\n## 层级选择器\n\n| 名称       | 用法        | 描述                                                        |\n| ---------- | ----------- | :---------------------------------------------------------- |\n| 子代选择器 | $(“ul>li”); | 使用>号，获取儿子层级的元素，注意，并不会获取孙子层级的元素 |\n| 后代选择器 | $(“ul li”); | 使用空格，代表后代选择器，获取ul下的所有li元素，包括孙子等  |\n\n\n\n> 跟CSS的选择器一模一样。\n\n## 过滤选择器\n\n> 这类选择器都带冒号:\n\n| 名称         | 用法                               | 描述                                                        |\n| ------------ | ---------------------------------- | :---------------------------------------------------------- |\n| :eq（index） | $(“li:eq(2)”).css(“color”, ”red”); | 获取到的li元素中，选择索引号为2的元素，索引号index从0开始。 |\n| :odd         | $(“li:odd”).css(“color”, ”red”);   | 获取到的li元素中，选择索引号为奇数的元素                    |\n| :even        | $(“li:even”).css(“color”, ”red”);  | 获取到的li元素中，选择索引号为偶数的元素                    |\n\n\n## 筛选选择器(方法)\n\n> 筛选选择器的功能与过滤选择器有点类似，但是用法不一样，筛选选择器主要是方法。\n\n| 名称               | 用法                        | 描述                             |\n| ------------------ | --------------------------- | :------------------------------- |\n| children(selector) | $(“ul”).children(“li”)      | 相当于$(“ul>li”)，子类选择器     |\n| find(selector)     | $(“ul”).find(“li”);         | 相当于$(“ul li”),后代选择器      |\n| siblings(selector) | $(“#first”).siblings(“li”); | 查找兄弟节点，不包括自己本身。   |\n| parent()           | $(“#first”).parent();       | 查找父亲                         |\n| eq(index)          | $(“li”).eq(2);              | 相当于$(“li:eq(2)”),index从0开始 |\n| next()             | $(“li”).next()              | 找下一个兄弟                     |\n| prev()             | $(“li”).prev()              | 找上一次兄弟                     |","id":11},{"title":"队列结构","time":1540809940,"intro":"嘟嘟","content":"### 队列的数据结构\r\n\r\n#### enqueue(入队)\r\n\r\n> 往array末尾添加元素，就叫入队\r\n\r\n#### dequeue（出队）\r\n\r\n> 删除array队首(最早添加)的元素，并返回其值。叫出队\r\n\r\n#### 例子\r\n\r\n> 下面的例子就是表示的队列结构，只需要调用响应的方法就可以实现相应功能\r\n\r\n```js\r\n// 队列结构\r\n// 主要有 2 个操作\r\n// enqueue dequeue\r\n//\r\nvar Queue = function() {\r\n    // data 是存储元素的数组\r\n    this.data = []\r\n}\r\n\r\n// 入队\r\nQueue.prototype.enqueue = function (element) {\r\n    this.data.push(element)\r\n}\r\n\r\n// 出队\r\nQueue.prototype.dequeue = function () {\r\n    return this.data.splice(0, 1)[0]\r\n}\r\n\r\n// 队列长度\r\nQueue.prototype.length = function () {\r\n    return this.data.length\r\n}\r\n\r\n// 清空队列\r\nQueue.prototype.empty = function() {\r\n    this.data = []\r\n}\r\n```\r\n\r\n\r\n\r\n","id":12},{"title":"栈","time":1540809961,"intro":"蓝赛飞龙路反思开了","content":"### stack 栈\r\n\r\n> 常见的操作 \r\n>\r\n> push(往栈里添加一个元素) \r\n>\r\n> pop(从栈里弹出一个最新添加元素，并删除) \r\n>\r\n> top(仅返回最新添加的元素，不删)\r\n\r\n\r\n\r\n### 例子\r\n\r\n ```js\r\nvar Stack = function() {\r\n    this.data = []\r\n}\r\n\r\n// push 添加一个元素\r\nStack.prototype.push = function(e) {\r\n    this.data.push(e)\r\n}\r\n\r\n// pop 删除并返回最新添加的元素\r\nStack.prototype.pop = function() {\r\n    var index = this.data.length - 1\r\n    return this.data.splice(index, 1)[0]\r\n}\r\n\r\n// top 仅返回最新添加的元素\r\nStack.prototype.top = function() {\r\n    var index = this.data.length - 1\r\n    return this.data[index]\r\n}\r\n\r\nvar s = new Stack()\r\ns.push('hello')\r\ns.push('world')\r\nconsole.log(s.pop()) // 这里就会先返回'world'\r\nconsole.log(s.pop()) // 再返回'hello'\r\n\r\nvar str = 'hello'\r\n// 这里把 str push到了array中\r\nfor (var i = 0; i < str.length; i++) {\r\n    s.push(str[i])\r\n}\r\n\r\n// 再pop到str1中，就实现了倒序\r\nvar str1 = ''\r\nfor (var i = 0; i < str.length; i++) {\r\n    str1 += s.pop()\r\n}\r\nconsole.log(str1)\r\n ```\r\n\r\n### 例子：验证括号匹配\r\n\r\n> 核心思想：\r\n>\r\n> ​\t遇到`(`push到array中，遇到`)`pop出来，如果最后array里为空，那么验证成功\r\n\r\n```js\r\n/*\r\n((1 + 2) * 3)\r\n*/\r\nvar Stack = function() {\r\n    this.data = []\r\n}\r\n\r\n// push 添加一个元素\r\nStack.prototype.push = function(e) {\r\n    this.data.push(e)\r\n}\r\n\r\n// pop 删除并返回最新添加的元素\r\nStack.prototype.pop = function() {\r\n    var index = this.data.length - 1\r\n    return this.data.splice(index, 1)\r\n}\r\n\r\n// top 仅返回最新添加的元素\r\nStack.prototype.top = function() {\r\n    var index = this.data.length - 1\r\n    return this.data[index]\r\n}\r\n\r\n\r\nvar s = new Stack\r\n\r\nvar str = '((1 + 2) * 3)'\r\n\r\nfor (var i = 0; i < str.length; i++) {\r\n    if (str[i] === '(') {\r\n        s.data.push(str[i])\r\n    } else if (str[i] === ')') {\r\n        s.data.pop(str[i])\r\n    }\r\n}\r\n\r\nif (JSON.stringify(s.data) === '[]') {\r\n    console.log('验证成功')\r\n}\r\n```\r\n\r\n","id":13},{"title":"链表","time":1540809977,"intro":"开了房速龙扥JS凯龙凯龙凯龙凯龙凯龙凯龙凯龙凯龙凯龙开了 ","content":"### 链表 (LinkedList)\r\n\r\n> 链表是几乎所有数据结构的基础\r\n\r\n### 复杂度概念\r\n\r\n> 时间、空间复杂度\r\n> 复杂度是对一个操作的大致估计\r\n> 复杂度从小到大依次如下\r\n>\r\n> **五种常见时间复杂度:**\r\n>\r\n> 1. O(1)  常数复杂度，比如在数组的最后增加一个元素\r\n>          或者 读取数组的第一个元素\r\n>          或者 读取链表的第 100 个元素\r\n>          (也就是说，不管数据量有多大，读取的时间都不会变)\r\n>\r\n> 2. O(logN) 比如二分搜索， 常用于有序列表的查找\r\n>          (把一串有序的元素不断的二等分，同样在量小的时候不划算，但量大了就比一个个的对比快很多)\r\n>\r\n> 3. O(n)    从头到尾的遍历， 比如给数组中每个数字加 1\r\n>\r\n> 4. O(NlogN)两个有序列表，求交集，用二分搜索\r\n>          (有数组a、b，把a的元素一个个拿出来，和b进行二分搜索)\r\n>\r\n> 5. O(N²)   两个列表求交集\r\n>          (那就是，两个列表一个一个的对比了)\r\n>\r\n> **空间复杂度:**\r\n>\r\n> O(1)    在一个数组中 找到最大的元素并返回\r\n>\r\n> O(n)    复制一个数组并返回 (这里数据越多n越大)\r\n\r\n\r\n\r\n### 链表实现\r\n\r\n```js\r\nvar Node = function(e) {\r\n\r\n    this.element = e\r\n\r\n    this.next = null\r\n\r\n}\r\n\r\n// 实现原理：\r\n// 这里 让n1.next 指向n2 又让n2.next 指向 n3 这就实现了前手拉后手\r\n//\r\n// var n1 = new Node(1)\r\n// var n2 = new Node(2)\r\n// var n3 = new Node(3)\r\n//\r\n// n1.next = n2\r\n// n2.next = n3\r\n//\r\n// 不断的给n通过.next赋值向下一个实例，并log出来，实现遍历上面的e\r\n//\r\n// var n = n1\r\n// while(n != null) {\r\n//     log('遍历链表', n.element)\r\n//     n = n.next\r\n// }\r\n\r\n// ---------------------------------------------------------\r\nvar LinkedList = function() {\r\n\r\n    this.head = new Node()\r\n\r\n    this._length = 0\r\n\r\n}\r\n\r\n\r\n// 在链表末尾增加一个元素 append\r\nLinkedList.prototype.append = function(e) {\r\n\r\n    var node = new Node(e)\r\n\r\n    var n = this.head\r\n\r\n    while(n.next != null) {\r\n\r\n        n = n.next\r\n\r\n    }\r\n\r\n    n.next = node\r\n\r\n    //\r\n\r\n    this._length++\r\n\r\n}\r\n\r\n\r\n// 返回一个元素的 indexOf\r\nLinkedList.prototype.indexOf = function(e) {\r\n\r\n    var index = -1\r\n\r\n    var n = this.head\r\n\r\n    var i = 0\r\n\r\n    while(n.next != null) {\r\n\r\n        if (e === n.element) {\r\n\r\n            index = i\r\n\r\n            break\r\n\r\n        }\r\n\r\n        n = n.next\r\n\r\n        i++\r\n\r\n    }\r\n\r\n    return index\r\n\r\n}\r\n\r\n\r\n// 返回链表的长度 .length\r\nLinkedList.prototype.length = function() {\r\n\r\n    return this._length\r\n\r\n}\r\n\r\nLinkedList.prototype.log = function() {\r\n\r\n    var n = this.head.next\r\n\r\n    log('遍历链表')\r\n\r\n    while(n != null) {\r\n\r\n        log(' > ', n.element)\r\n\r\n        n = n.next\r\n\r\n    }\r\n\r\n}\r\n\r\nvar list = new LinkedList()\r\n\r\nlist.append('hello')\r\n\r\nlist.append('gua')\r\n\r\nlist.append('你好')\r\n\r\nlist.log()\r\n\r\nlog(list.length())\r\n\r\n```\r\n\r\n","id":14},{"title":"哈希表","time":1540809998,"intro":"哈希表笔记度晒度","content":"```js\r\nhash table  哈希表（散列表）\r\nset         集合\r\ntree        树\r\ngraph       图\r\n\r\n\r\n哈希表就是用 字符串 当下标，也就是 js 中的对象的实现方式\r\n也就是其他语言中的 字典\r\n\r\n原理是用字符串 算出一个数字 然后用这个数字当下标存东西\r\n比如 gua 这个字符串 我们用每个字符乘以一个数字最后求余得到下标\r\n从字符串到数字的操作叫做 hash\r\n// hash('gua') = 1\r\n// hash('hs') = 3\r\n【坑1， 坑2， 坑3， 坑4， 坑5， 坑6】\r\n  gua        hs               wh\r\n  xiao       lj\r\n             bl\r\n\r\n```\r\n\r\n","id":15},{"title":"nodejs基础","time":1540810062,"intro":"nodejs基础介绍度晒晒嘟嘟嘟","content":"### 1.导入方法，require\n\n注意不要把require逻辑搞复杂，比如：`a->b b->c c->a`,可能会导致require个空对象，因为没加载完。\n\n**使用方法：**\n\n```js\nvar fs = require('fs')\n```\n\n### 2.导出方法，exports 和 module.exports\n\n**使用方法：**\n\n```js\nexports = {...}\n```\n\n**两者区别：**\n\n```js\n//其实exports就是一个简写罢了，nodejs帮我们做了一件事：\nexports = module.exports\n//如果module.exports指向了一个新的对象，那么exports就断开了和齐的连接\n//可以这样写，把他们重新关联起来:\nexports = module.exports = {...}\n```\n\n**实在搞不懂，就用`module.exports`**\n\n### 3.Promise，处理异步代码\n\n**基本使用**\n\n```js\n// Promise的两个参数均为回调函数，resolve在回调成功时调用，reject在失败时调用。会把参数return出去\nvar timeout = function(ms) {\n    return new Promise(function(resolve, reject) {\n        setTimeout(function() {\n            resolve('成功')\n        } ,ms)\n    })\n}\n// 这里then的第一个参数为:回调成功后的处理函数，函数的参数为上面return的值\n//then(value, err)第二个参数处理失败，可以不写\n//then(undefined, /*处理错误*/)\ntimeout(1000).then(function(value) {\n    console.log(value)\n})\n// 1s后打印出>>>'成功'\n\n//`处理失败`还提供了个catch()方法\ntimeout(1000).then().catch(/*处理失败*/)\n//`无论失败与否`，都会执行的方法：finally() \n```\n\n**具体教程：**[阮一峰s6](http://es6.ruanyifeng.com/#docs/promise)、[开源迷你书](http://liubin.org/promises-book/)\n\n\n\n\n\n\n\n","id":16},{"title":"Express基础","time":1540810098,"intro":"express基础笔记，比较短","content":"### 初始化配置\n\n#### 初始化项目：\n\n```shell\n# 在项目目录，输入\nnpm init\n```\n\n#### 安装`express`\n\n```shell\nnpm i express --save\n```\n\n#### 使用`express`\n\n```js\nconst express = require('express')\nconst app = express()\n\napp.get('/', function (req, res) {\n  res.send('hello, express')\n})\n\napp.listen(3000)\n```\n\n### 自动重启工具\n\n```shell\n# 安装\nnpm install --global nodemon\n# 验证是否安装成功\nnodemon --version\n# 启动\nnodemon XXX.js\n```\n\n### 配置路由\n\n`index.js`是入口文件，仅配置用\n\n把路由模块都放在`routes`目录\n\n**入口文件：index.js**\n\n```js\nconst express = require('express')\nconst app = express()\n// 引入路由模块\nconst indexRouter = require('./routes/index')\nconst userRouter = require('./routes/users')\n// 载入路由\napp.use(indexRouter)\napp.use(userRouter)\n\napp.listen(3000)\n```\n\n**路由模块一：routes/index.js** \n\n```js\nconst express = require('express')\nconst router = express.Router()\n\nrouter.get('/', function (req, res) {\n  res.send('hello, express')\n})\n\nmodule.exports = router\n```\n\n**路由模块二：routes/users.js** \n\n```js\nconst express = require('express')\nconst router = express.Router()\n\nrouter.get('/users/:name', function (req, res) {\n  res.send('hello, ' + req.params.name)\n})\n\nmodule.exports = router\n```\n\n","id":17},{"title":"ejs模板引擎","time":1540810128,"intro":"ejs模板引擎笔记，嘟嘟嘟","content":"### 安装\n\n```shell\nnpm i ejs --save\n```\n\n### 入口文件：index.js 这样配置\n\n```js\nconst path = require('path')\nconst express = require('express')\nconst app = express()\nconst indexRouter = require('./routes/index')\nconst userRouter = require('./routes/users')\n\n// 在这里配置ejs\napp.set('views', path.join(__dirname, 'views'))// 设置存放模板文件的目录\napp.set('view engine', 'ejs')// 设置模板引擎为 ejs\n\napp.use(indexRouter)\napp.use(userRouter)\n\napp.listen(3000)\n```\n\n### 路由文件里这样用\n\n在myblog目录(项目目录)下新建views文件夹，内放模板文件\n\n**views/users.ejs**\n\n```html\n<!DOCTYPE html>\n<html>\n\n<head>\n    <style type=\"text/css\">\n        body {\n            padding: 50px;\n            font: 14px \"Lucida Grande\", Helvetica, Arial, sans-serif;\n        }\n    </style>\n</head>\n\n<body>\n    <h1><%= name.toUpperCase() %></h1>\n    <p>hello, <%= name %></p>\n</body>\n\n</html>\n```\n\n**路由里这样配置：routes/users.js**\n\n```js\nconst express = require('express')\nconst router = express.Router()\n\nrouter.get('/users/:name', function(req, res) {\n    // 参数一：模板位置，参数二：变量(用于替换模板内容)\n    res.render('users', {\n        // 这里获取到`:name`对应的内容\n        name: req.params.name\n    })\n})\n\nmodule.exports = router\n```\n\n### ejs有3种常用标签\n\n1. `<% code %>`：运行 JavaScript 代码，不输出\n2. `<%= code %>`：仅显示字符串，标签会被当做字符串渲染到页面\n3. `<%- code %>`：可解析html标签\n\n下面的例子解释了 `<% code %>` 的用法：\n\n**数据**\n\n```js\nsupplies: ['mop', 'broom', 'duster']\n```\n\n**模板**\n\n```ejs\n<ul>\n<% for(var i=0; i<supplies.length; i++) {%>\n   <li><%= supplies[i] %></li>\n<% } %>\n</ul>\n```\n\n**渲染结果**\n\n```html\n<ul>\n  <li>mop</li>\n  <li>broom</li>\n  <li>duster</li>\n</ul>\n```\n\n### includes 模板模块化\n\n**views/header.ejs**\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <style type=\"text/css\">\n      body {padding: 50px;font: 14px \"Lucida Grande\", Helvetica, Arial, sans-serif;}\n    </style>\n  </head>\n  <body>\n```\n\n**views/footer.ejs**\n\n```html\n  </body>\n</html>\n```\n\n**views/users.ejs**\n\n```ejs\n<%- include('header') %>\n  <h1><%= name.toUpperCase() %></h1>\n  <p>hello, <%= name %></p>\n<%- include('footer') %>\n```\n\n我们将原来的 users.ejs 拆成出了 header.ejs 和 footer.ejs，并在 users.ejs 通过 ejs 内置的 include 方法引入，从而实现了跟以前一个模板文件相同的功能。\n\n> 小提示：拆分模板组件通常有两个好处：\n>\n> 1. 模板可复用，减少重复代码\n> 2. 主模板结构清晰\n\n> 注意：要用 `<%- include('header') %>` 而不是 `<%= include('header') %>`\n\n","id":18},{"title":"ejs模板引擎","time":1540820675,"intro":"ejs模板引擎笔记，嘟嘟嘟","content":"### 安装\n\n```shell\nnpm i ejs --save\n```\n\n### 入口文件：index.js 这样配置\n\n```js\nconst path = require('path')\nconst express = require('express')\nconst app = express()\nconst indexRouter = require('./routes/index')\nconst userRouter = require('./routes/users')\n\n// 在这里配置ejs\napp.set('views', path.join(__dirname, 'views'))// 设置存放模板文件的目录\napp.set('view engine', 'ejs')// 设置模板引擎为 ejs\n\napp.use(indexRouter)\napp.use(userRouter)\n\napp.listen(3000)\n```\n\n### 路由文件里这样用\n\n在myblog目录(项目目录)下新建views文件夹，内放模板文件\n\n**views/users.ejs**\n\n```html\n<!DOCTYPE html>\n<html>\n\n<head>\n    <style type=\"text/css\">\n        body {\n            padding: 50px;\n            font: 14px \"Lucida Grande\", Helvetica, Arial, sans-serif;\n        }\n    </style>\n</head>\n\n<body>\n    <h1><%= name.toUpperCase() %></h1>\n    <p>hello, <%= name %></p>\n</body>\n\n</html>\n```\n\n**路由里这样配置：routes/users.js**\n\n```js\nconst express = require('express')\nconst router = express.Router()\n\nrouter.get('/users/:name', function(req, res) {\n    // 参数一：模板位置，参数二：变量(用于替换模板内容)\n    res.render('users', {\n        // 这里获取到`:name`对应的内容\n        name: req.params.name\n    })\n})\n\nmodule.exports = router\n```\n\n### ejs有3种常用标签\n\n1. `<% code %>`：运行 JavaScript 代码，不输出\n2. `<%= code %>`：仅显示字符串，标签会被当做字符串渲染到页面\n3. `<%- code %>`：可解析html标签\n\n下面的例子解释了 `<% code %>` 的用法：\n\n**数据**\n\n```js\nsupplies: ['mop', 'broom', 'duster']\n```\n\n**模板**\n\n```ejs\n<ul>\n<% for(var i=0; i<supplies.length; i++) {%>\n   <li><%= supplies[i] %></li>\n<% } %>\n</ul>\n```\n\n**渲染结果**\n\n```html\n<ul>\n  <li>mop</li>\n  <li>broom</li>\n  <li>duster</li>\n</ul>\n```\n\n### includes 模板模块化\n\n**views/header.ejs**\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <style type=\"text/css\">\n      body {padding: 50px;font: 14px \"Lucida Grande\", Helvetica, Arial, sans-serif;}\n    </style>\n  </head>\n  <body>\n```\n\n**views/footer.ejs**\n\n```html\n  </body>\n</html>\n```\n\n**views/users.ejs**\n\n```ejs\n<%- include('header') %>\n  <h1><%= name.toUpperCase() %></h1>\n  <p>hello, <%= name %></p>\n<%- include('footer') %>\n```\n\n我们将原来的 users.ejs 拆成出了 header.ejs 和 footer.ejs，并在 users.ejs 通过 ejs 内置的 include 方法引入，从而实现了跟以前一个模板文件相同的功能。\n\n> 小提示：拆分模板组件通常有两个好处：\n>\n> 1. 模板可复用，减少重复代码\n> 2. 主模板结构清晰\n\n> 注意：要用 `<%- include('header') %>` 而不是 `<%= include('header') %>`\n\n","id":19},{"title":"ejs模板引擎","time":1540820676,"intro":"ejs模板引擎笔记，嘟嘟嘟","content":"### 安装\n\n```shell\nnpm i ejs --save\n```\n\n### 入口文件：index.js 这样配置\n\n```js\nconst path = require('path')\nconst express = require('express')\nconst app = express()\nconst indexRouter = require('./routes/index')\nconst userRouter = require('./routes/users')\n\n// 在这里配置ejs\napp.set('views', path.join(__dirname, 'views'))// 设置存放模板文件的目录\napp.set('view engine', 'ejs')// 设置模板引擎为 ejs\n\napp.use(indexRouter)\napp.use(userRouter)\n\napp.listen(3000)\n```\n\n### 路由文件里这样用\n\n在myblog目录(项目目录)下新建views文件夹，内放模板文件\n\n**views/users.ejs**\n\n```html\n<!DOCTYPE html>\n<html>\n\n<head>\n    <style type=\"text/css\">\n        body {\n            padding: 50px;\n            font: 14px \"Lucida Grande\", Helvetica, Arial, sans-serif;\n        }\n    </style>\n</head>\n\n<body>\n    <h1><%= name.toUpperCase() %></h1>\n    <p>hello, <%= name %></p>\n</body>\n\n</html>\n```\n\n**路由里这样配置：routes/users.js**\n\n```js\nconst express = require('express')\nconst router = express.Router()\n\nrouter.get('/users/:name', function(req, res) {\n    // 参数一：模板位置，参数二：变量(用于替换模板内容)\n    res.render('users', {\n        // 这里获取到`:name`对应的内容\n        name: req.params.name\n    })\n})\n\nmodule.exports = router\n```\n\n### ejs有3种常用标签\n\n1. `<% code %>`：运行 JavaScript 代码，不输出\n2. `<%= code %>`：仅显示字符串，标签会被当做字符串渲染到页面\n3. `<%- code %>`：可解析html标签\n\n下面的例子解释了 `<% code %>` 的用法：\n\n**数据**\n\n```js\nsupplies: ['mop', 'broom', 'duster']\n```\n\n**模板**\n\n```ejs\n<ul>\n<% for(var i=0; i<supplies.length; i++) {%>\n   <li><%= supplies[i] %></li>\n<% } %>\n</ul>\n```\n\n**渲染结果**\n\n```html\n<ul>\n  <li>mop</li>\n  <li>broom</li>\n  <li>duster</li>\n</ul>\n```\n\n### includes 模板模块化\n\n**views/header.ejs**\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <style type=\"text/css\">\n      body {padding: 50px;font: 14px \"Lucida Grande\", Helvetica, Arial, sans-serif;}\n    </style>\n  </head>\n  <body>\n```\n\n**views/footer.ejs**\n\n```html\n  </body>\n</html>\n```\n\n**views/users.ejs**\n\n```ejs\n<%- include('header') %>\n  <h1><%= name.toUpperCase() %></h1>\n  <p>hello, <%= name %></p>\n<%- include('footer') %>\n```\n\n我们将原来的 users.ejs 拆成出了 header.ejs 和 footer.ejs，并在 users.ejs 通过 ejs 内置的 include 方法引入，从而实现了跟以前一个模板文件相同的功能。\n\n> 小提示：拆分模板组件通常有两个好处：\n>\n> 1. 模板可复用，减少重复代码\n> 2. 主模板结构清晰\n\n> 注意：要用 `<%- include('header') %>` 而不是 `<%= include('header') %>`\n\n","id":20},{"title":"ejs模板引擎","time":1540820676,"intro":"ejs模板引擎笔记，嘟嘟嘟","content":"### 安装\n\n```shell\nnpm i ejs --save\n```\n\n### 入口文件：index.js 这样配置\n\n```js\nconst path = require('path')\nconst express = require('express')\nconst app = express()\nconst indexRouter = require('./routes/index')\nconst userRouter = require('./routes/users')\n\n// 在这里配置ejs\napp.set('views', path.join(__dirname, 'views'))// 设置存放模板文件的目录\napp.set('view engine', 'ejs')// 设置模板引擎为 ejs\n\napp.use(indexRouter)\napp.use(userRouter)\n\napp.listen(3000)\n```\n\n### 路由文件里这样用\n\n在myblog目录(项目目录)下新建views文件夹，内放模板文件\n\n**views/users.ejs**\n\n```html\n<!DOCTYPE html>\n<html>\n\n<head>\n    <style type=\"text/css\">\n        body {\n            padding: 50px;\n            font: 14px \"Lucida Grande\", Helvetica, Arial, sans-serif;\n        }\n    </style>\n</head>\n\n<body>\n    <h1><%= name.toUpperCase() %></h1>\n    <p>hello, <%= name %></p>\n</body>\n\n</html>\n```\n\n**路由里这样配置：routes/users.js**\n\n```js\nconst express = require('express')\nconst router = express.Router()\n\nrouter.get('/users/:name', function(req, res) {\n    // 参数一：模板位置，参数二：变量(用于替换模板内容)\n    res.render('users', {\n        // 这里获取到`:name`对应的内容\n        name: req.params.name\n    })\n})\n\nmodule.exports = router\n```\n\n### ejs有3种常用标签\n\n1. `<% code %>`：运行 JavaScript 代码，不输出\n2. `<%= code %>`：仅显示字符串，标签会被当做字符串渲染到页面\n3. `<%- code %>`：可解析html标签\n\n下面的例子解释了 `<% code %>` 的用法：\n\n**数据**\n\n```js\nsupplies: ['mop', 'broom', 'duster']\n```\n\n**模板**\n\n```ejs\n<ul>\n<% for(var i=0; i<supplies.length; i++) {%>\n   <li><%= supplies[i] %></li>\n<% } %>\n</ul>\n```\n\n**渲染结果**\n\n```html\n<ul>\n  <li>mop</li>\n  <li>broom</li>\n  <li>duster</li>\n</ul>\n```\n\n### includes 模板模块化\n\n**views/header.ejs**\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <style type=\"text/css\">\n      body {padding: 50px;font: 14px \"Lucida Grande\", Helvetica, Arial, sans-serif;}\n    </style>\n  </head>\n  <body>\n```\n\n**views/footer.ejs**\n\n```html\n  </body>\n</html>\n```\n\n**views/users.ejs**\n\n```ejs\n<%- include('header') %>\n  <h1><%= name.toUpperCase() %></h1>\n  <p>hello, <%= name %></p>\n<%- include('footer') %>\n```\n\n我们将原来的 users.ejs 拆成出了 header.ejs 和 footer.ejs，并在 users.ejs 通过 ejs 内置的 include 方法引入，从而实现了跟以前一个模板文件相同的功能。\n\n> 小提示：拆分模板组件通常有两个好处：\n>\n> 1. 模板可复用，减少重复代码\n> 2. 主模板结构清晰\n\n> 注意：要用 `<%- include('header') %>` 而不是 `<%= include('header') %>`\n\n","id":21},{"title":"ejs模板引擎","time":1540820677,"intro":"ejs模板引擎笔记，嘟嘟嘟","content":"### 安装\n\n```shell\nnpm i ejs --save\n```\n\n### 入口文件：index.js 这样配置\n\n```js\nconst path = require('path')\nconst express = require('express')\nconst app = express()\nconst indexRouter = require('./routes/index')\nconst userRouter = require('./routes/users')\n\n// 在这里配置ejs\napp.set('views', path.join(__dirname, 'views'))// 设置存放模板文件的目录\napp.set('view engine', 'ejs')// 设置模板引擎为 ejs\n\napp.use(indexRouter)\napp.use(userRouter)\n\napp.listen(3000)\n```\n\n### 路由文件里这样用\n\n在myblog目录(项目目录)下新建views文件夹，内放模板文件\n\n**views/users.ejs**\n\n```html\n<!DOCTYPE html>\n<html>\n\n<head>\n    <style type=\"text/css\">\n        body {\n            padding: 50px;\n            font: 14px \"Lucida Grande\", Helvetica, Arial, sans-serif;\n        }\n    </style>\n</head>\n\n<body>\n    <h1><%= name.toUpperCase() %></h1>\n    <p>hello, <%= name %></p>\n</body>\n\n</html>\n```\n\n**路由里这样配置：routes/users.js**\n\n```js\nconst express = require('express')\nconst router = express.Router()\n\nrouter.get('/users/:name', function(req, res) {\n    // 参数一：模板位置，参数二：变量(用于替换模板内容)\n    res.render('users', {\n        // 这里获取到`:name`对应的内容\n        name: req.params.name\n    })\n})\n\nmodule.exports = router\n```\n\n### ejs有3种常用标签\n\n1. `<% code %>`：运行 JavaScript 代码，不输出\n2. `<%= code %>`：仅显示字符串，标签会被当做字符串渲染到页面\n3. `<%- code %>`：可解析html标签\n\n下面的例子解释了 `<% code %>` 的用法：\n\n**数据**\n\n```js\nsupplies: ['mop', 'broom', 'duster']\n```\n\n**模板**\n\n```ejs\n<ul>\n<% for(var i=0; i<supplies.length; i++) {%>\n   <li><%= supplies[i] %></li>\n<% } %>\n</ul>\n```\n\n**渲染结果**\n\n```html\n<ul>\n  <li>mop</li>\n  <li>broom</li>\n  <li>duster</li>\n</ul>\n```\n\n### includes 模板模块化\n\n**views/header.ejs**\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <style type=\"text/css\">\n      body {padding: 50px;font: 14px \"Lucida Grande\", Helvetica, Arial, sans-serif;}\n    </style>\n  </head>\n  <body>\n```\n\n**views/footer.ejs**\n\n```html\n  </body>\n</html>\n```\n\n**views/users.ejs**\n\n```ejs\n<%- include('header') %>\n  <h1><%= name.toUpperCase() %></h1>\n  <p>hello, <%= name %></p>\n<%- include('footer') %>\n```\n\n我们将原来的 users.ejs 拆成出了 header.ejs 和 footer.ejs，并在 users.ejs 通过 ejs 内置的 include 方法引入，从而实现了跟以前一个模板文件相同的功能。\n\n> 小提示：拆分模板组件通常有两个好处：\n>\n> 1. 模板可复用，减少重复代码\n> 2. 主模板结构清晰\n\n> 注意：要用 `<%- include('header') %>` 而不是 `<%= include('header') %>`\n\n","id":22},{"title":"ejs模板引擎","time":1540820688,"intro":"ejs模板引擎笔记，嘟嘟嘟","content":"### 安装\n\n```shell\nnpm i ejs --save\n```\n\n### 入口文件：index.js 这样配置\n\n```js\nconst path = require('path')\nconst express = require('express')\nconst app = express()\nconst indexRouter = require('./routes/index')\nconst userRouter = require('./routes/users')\n\n// 在这里配置ejs\napp.set('views', path.join(__dirname, 'views'))// 设置存放模板文件的目录\napp.set('view engine', 'ejs')// 设置模板引擎为 ejs\n\napp.use(indexRouter)\napp.use(userRouter)\n\napp.listen(3000)\n```\n\n### 路由文件里这样用\n\n在myblog目录(项目目录)下新建views文件夹，内放模板文件\n\n**views/users.ejs**\n\n```html\n<!DOCTYPE html>\n<html>\n\n<head>\n    <style type=\"text/css\">\n        body {\n            padding: 50px;\n            font: 14px \"Lucida Grande\", Helvetica, Arial, sans-serif;\n        }\n    </style>\n</head>\n\n<body>\n    <h1><%= name.toUpperCase() %></h1>\n    <p>hello, <%= name %></p>\n</body>\n\n</html>\n```\n\n**路由里这样配置：routes/users.js**\n\n```js\nconst express = require('express')\nconst router = express.Router()\n\nrouter.get('/users/:name', function(req, res) {\n    // 参数一：模板位置，参数二：变量(用于替换模板内容)\n    res.render('users', {\n        // 这里获取到`:name`对应的内容\n        name: req.params.name\n    })\n})\n\nmodule.exports = router\n```\n\n### ejs有3种常用标签\n\n1. `<% code %>`：运行 JavaScript 代码，不输出\n2. `<%= code %>`：仅显示字符串，标签会被当做字符串渲染到页面\n3. `<%- code %>`：可解析html标签\n\n下面的例子解释了 `<% code %>` 的用法：\n\n**数据**\n\n```js\nsupplies: ['mop', 'broom', 'duster']\n```\n\n**模板**\n\n```ejs\n<ul>\n<% for(var i=0; i<supplies.length; i++) {%>\n   <li><%= supplies[i] %></li>\n<% } %>\n</ul>\n```\n\n**渲染结果**\n\n```html\n<ul>\n  <li>mop</li>\n  <li>broom</li>\n  <li>duster</li>\n</ul>\n```\n\n### includes 模板模块化\n\n**views/header.ejs**\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <style type=\"text/css\">\n      body {padding: 50px;font: 14px \"Lucida Grande\", Helvetica, Arial, sans-serif;}\n    </style>\n  </head>\n  <body>\n```\n\n**views/footer.ejs**\n\n```html\n  </body>\n</html>\n```\n\n**views/users.ejs**\n\n```ejs\n<%- include('header') %>\n  <h1><%= name.toUpperCase() %></h1>\n  <p>hello, <%= name %></p>\n<%- include('footer') %>\n```\n\n我们将原来的 users.ejs 拆成出了 header.ejs 和 footer.ejs，并在 users.ejs 通过 ejs 内置的 include 方法引入，从而实现了跟以前一个模板文件相同的功能。\n\n> 小提示：拆分模板组件通常有两个好处：\n>\n> 1. 模板可复用，减少重复代码\n> 2. 主模板结构清晰\n\n> 注意：要用 `<%- include('header') %>` 而不是 `<%= include('header') %>`\n\n","id":23},{"title":"ejs模板引擎","time":1540820688,"intro":"ejs模板引擎笔记，嘟嘟嘟","content":"### 安装\n\n```shell\nnpm i ejs --save\n```\n\n### 入口文件：index.js 这样配置\n\n```js\nconst path = require('path')\nconst express = require('express')\nconst app = express()\nconst indexRouter = require('./routes/index')\nconst userRouter = require('./routes/users')\n\n// 在这里配置ejs\napp.set('views', path.join(__dirname, 'views'))// 设置存放模板文件的目录\napp.set('view engine', 'ejs')// 设置模板引擎为 ejs\n\napp.use(indexRouter)\napp.use(userRouter)\n\napp.listen(3000)\n```\n\n### 路由文件里这样用\n\n在myblog目录(项目目录)下新建views文件夹，内放模板文件\n\n**views/users.ejs**\n\n```html\n<!DOCTYPE html>\n<html>\n\n<head>\n    <style type=\"text/css\">\n        body {\n            padding: 50px;\n            font: 14px \"Lucida Grande\", Helvetica, Arial, sans-serif;\n        }\n    </style>\n</head>\n\n<body>\n    <h1><%= name.toUpperCase() %></h1>\n    <p>hello, <%= name %></p>\n</body>\n\n</html>\n```\n\n**路由里这样配置：routes/users.js**\n\n```js\nconst express = require('express')\nconst router = express.Router()\n\nrouter.get('/users/:name', function(req, res) {\n    // 参数一：模板位置，参数二：变量(用于替换模板内容)\n    res.render('users', {\n        // 这里获取到`:name`对应的内容\n        name: req.params.name\n    })\n})\n\nmodule.exports = router\n```\n\n### ejs有3种常用标签\n\n1. `<% code %>`：运行 JavaScript 代码，不输出\n2. `<%= code %>`：仅显示字符串，标签会被当做字符串渲染到页面\n3. `<%- code %>`：可解析html标签\n\n下面的例子解释了 `<% code %>` 的用法：\n\n**数据**\n\n```js\nsupplies: ['mop', 'broom', 'duster']\n```\n\n**模板**\n\n```ejs\n<ul>\n<% for(var i=0; i<supplies.length; i++) {%>\n   <li><%= supplies[i] %></li>\n<% } %>\n</ul>\n```\n\n**渲染结果**\n\n```html\n<ul>\n  <li>mop</li>\n  <li>broom</li>\n  <li>duster</li>\n</ul>\n```\n\n### includes 模板模块化\n\n**views/header.ejs**\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <style type=\"text/css\">\n      body {padding: 50px;font: 14px \"Lucida Grande\", Helvetica, Arial, sans-serif;}\n    </style>\n  </head>\n  <body>\n```\n\n**views/footer.ejs**\n\n```html\n  </body>\n</html>\n```\n\n**views/users.ejs**\n\n```ejs\n<%- include('header') %>\n  <h1><%= name.toUpperCase() %></h1>\n  <p>hello, <%= name %></p>\n<%- include('footer') %>\n```\n\n我们将原来的 users.ejs 拆成出了 header.ejs 和 footer.ejs，并在 users.ejs 通过 ejs 内置的 include 方法引入，从而实现了跟以前一个模板文件相同的功能。\n\n> 小提示：拆分模板组件通常有两个好处：\n>\n> 1. 模板可复用，减少重复代码\n> 2. 主模板结构清晰\n\n> 注意：要用 `<%- include('header') %>` 而不是 `<%= include('header') %>`\n\n","id":24},{"title":"ejs模板引擎","time":1540820689,"intro":"ejs模板引擎笔记，嘟嘟嘟","content":"### 安装\n\n```shell\nnpm i ejs --save\n```\n\n### 入口文件：index.js 这样配置\n\n```js\nconst path = require('path')\nconst express = require('express')\nconst app = express()\nconst indexRouter = require('./routes/index')\nconst userRouter = require('./routes/users')\n\n// 在这里配置ejs\napp.set('views', path.join(__dirname, 'views'))// 设置存放模板文件的目录\napp.set('view engine', 'ejs')// 设置模板引擎为 ejs\n\napp.use(indexRouter)\napp.use(userRouter)\n\napp.listen(3000)\n```\n\n### 路由文件里这样用\n\n在myblog目录(项目目录)下新建views文件夹，内放模板文件\n\n**views/users.ejs**\n\n```html\n<!DOCTYPE html>\n<html>\n\n<head>\n    <style type=\"text/css\">\n        body {\n            padding: 50px;\n            font: 14px \"Lucida Grande\", Helvetica, Arial, sans-serif;\n        }\n    </style>\n</head>\n\n<body>\n    <h1><%= name.toUpperCase() %></h1>\n    <p>hello, <%= name %></p>\n</body>\n\n</html>\n```\n\n**路由里这样配置：routes/users.js**\n\n```js\nconst express = require('express')\nconst router = express.Router()\n\nrouter.get('/users/:name', function(req, res) {\n    // 参数一：模板位置，参数二：变量(用于替换模板内容)\n    res.render('users', {\n        // 这里获取到`:name`对应的内容\n        name: req.params.name\n    })\n})\n\nmodule.exports = router\n```\n\n### ejs有3种常用标签\n\n1. `<% code %>`：运行 JavaScript 代码，不输出\n2. `<%= code %>`：仅显示字符串，标签会被当做字符串渲染到页面\n3. `<%- code %>`：可解析html标签\n\n下面的例子解释了 `<% code %>` 的用法：\n\n**数据**\n\n```js\nsupplies: ['mop', 'broom', 'duster']\n```\n\n**模板**\n\n```ejs\n<ul>\n<% for(var i=0; i<supplies.length; i++) {%>\n   <li><%= supplies[i] %></li>\n<% } %>\n</ul>\n```\n\n**渲染结果**\n\n```html\n<ul>\n  <li>mop</li>\n  <li>broom</li>\n  <li>duster</li>\n</ul>\n```\n\n### includes 模板模块化\n\n**views/header.ejs**\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <style type=\"text/css\">\n      body {padding: 50px;font: 14px \"Lucida Grande\", Helvetica, Arial, sans-serif;}\n    </style>\n  </head>\n  <body>\n```\n\n**views/footer.ejs**\n\n```html\n  </body>\n</html>\n```\n\n**views/users.ejs**\n\n```ejs\n<%- include('header') %>\n  <h1><%= name.toUpperCase() %></h1>\n  <p>hello, <%= name %></p>\n<%- include('footer') %>\n```\n\n我们将原来的 users.ejs 拆成出了 header.ejs 和 footer.ejs，并在 users.ejs 通过 ejs 内置的 include 方法引入，从而实现了跟以前一个模板文件相同的功能。\n\n> 小提示：拆分模板组件通常有两个好处：\n>\n> 1. 模板可复用，减少重复代码\n> 2. 主模板结构清晰\n\n> 注意：要用 `<%- include('header') %>` 而不是 `<%= include('header') %>`\n\n","id":25},{"title":"ejs模板引擎","time":1540820690,"intro":"ejs模板引擎笔记，嘟嘟嘟","content":"### 安装\n\n```shell\nnpm i ejs --save\n```\n\n### 入口文件：index.js 这样配置\n\n```js\nconst path = require('path')\nconst express = require('express')\nconst app = express()\nconst indexRouter = require('./routes/index')\nconst userRouter = require('./routes/users')\n\n// 在这里配置ejs\napp.set('views', path.join(__dirname, 'views'))// 设置存放模板文件的目录\napp.set('view engine', 'ejs')// 设置模板引擎为 ejs\n\napp.use(indexRouter)\napp.use(userRouter)\n\napp.listen(3000)\n```\n\n### 路由文件里这样用\n\n在myblog目录(项目目录)下新建views文件夹，内放模板文件\n\n**views/users.ejs**\n\n```html\n<!DOCTYPE html>\n<html>\n\n<head>\n    <style type=\"text/css\">\n        body {\n            padding: 50px;\n            font: 14px \"Lucida Grande\", Helvetica, Arial, sans-serif;\n        }\n    </style>\n</head>\n\n<body>\n    <h1><%= name.toUpperCase() %></h1>\n    <p>hello, <%= name %></p>\n</body>\n\n</html>\n```\n\n**路由里这样配置：routes/users.js**\n\n```js\nconst express = require('express')\nconst router = express.Router()\n\nrouter.get('/users/:name', function(req, res) {\n    // 参数一：模板位置，参数二：变量(用于替换模板内容)\n    res.render('users', {\n        // 这里获取到`:name`对应的内容\n        name: req.params.name\n    })\n})\n\nmodule.exports = router\n```\n\n### ejs有3种常用标签\n\n1. `<% code %>`：运行 JavaScript 代码，不输出\n2. `<%= code %>`：仅显示字符串，标签会被当做字符串渲染到页面\n3. `<%- code %>`：可解析html标签\n\n下面的例子解释了 `<% code %>` 的用法：\n\n**数据**\n\n```js\nsupplies: ['mop', 'broom', 'duster']\n```\n\n**模板**\n\n```ejs\n<ul>\n<% for(var i=0; i<supplies.length; i++) {%>\n   <li><%= supplies[i] %></li>\n<% } %>\n</ul>\n```\n\n**渲染结果**\n\n```html\n<ul>\n  <li>mop</li>\n  <li>broom</li>\n  <li>duster</li>\n</ul>\n```\n\n### includes 模板模块化\n\n**views/header.ejs**\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <style type=\"text/css\">\n      body {padding: 50px;font: 14px \"Lucida Grande\", Helvetica, Arial, sans-serif;}\n    </style>\n  </head>\n  <body>\n```\n\n**views/footer.ejs**\n\n```html\n  </body>\n</html>\n```\n\n**views/users.ejs**\n\n```ejs\n<%- include('header') %>\n  <h1><%= name.toUpperCase() %></h1>\n  <p>hello, <%= name %></p>\n<%- include('footer') %>\n```\n\n我们将原来的 users.ejs 拆成出了 header.ejs 和 footer.ejs，并在 users.ejs 通过 ejs 内置的 include 方法引入，从而实现了跟以前一个模板文件相同的功能。\n\n> 小提示：拆分模板组件通常有两个好处：\n>\n> 1. 模板可复用，减少重复代码\n> 2. 主模板结构清晰\n\n> 注意：要用 `<%- include('header') %>` 而不是 `<%= include('header') %>`\n\n","id":26},{"title":"ejs模板引擎","time":1540820691,"intro":"ejs模板引擎笔记，嘟嘟嘟","content":"### 安装\n\n```shell\nnpm i ejs --save\n```\n\n### 入口文件：index.js 这样配置\n\n```js\nconst path = require('path')\nconst express = require('express')\nconst app = express()\nconst indexRouter = require('./routes/index')\nconst userRouter = require('./routes/users')\n\n// 在这里配置ejs\napp.set('views', path.join(__dirname, 'views'))// 设置存放模板文件的目录\napp.set('view engine', 'ejs')// 设置模板引擎为 ejs\n\napp.use(indexRouter)\napp.use(userRouter)\n\napp.listen(3000)\n```\n\n### 路由文件里这样用\n\n在myblog目录(项目目录)下新建views文件夹，内放模板文件\n\n**views/users.ejs**\n\n```html\n<!DOCTYPE html>\n<html>\n\n<head>\n    <style type=\"text/css\">\n        body {\n            padding: 50px;\n            font: 14px \"Lucida Grande\", Helvetica, Arial, sans-serif;\n        }\n    </style>\n</head>\n\n<body>\n    <h1><%= name.toUpperCase() %></h1>\n    <p>hello, <%= name %></p>\n</body>\n\n</html>\n```\n\n**路由里这样配置：routes/users.js**\n\n```js\nconst express = require('express')\nconst router = express.Router()\n\nrouter.get('/users/:name', function(req, res) {\n    // 参数一：模板位置，参数二：变量(用于替换模板内容)\n    res.render('users', {\n        // 这里获取到`:name`对应的内容\n        name: req.params.name\n    })\n})\n\nmodule.exports = router\n```\n\n### ejs有3种常用标签\n\n1. `<% code %>`：运行 JavaScript 代码，不输出\n2. `<%= code %>`：仅显示字符串，标签会被当做字符串渲染到页面\n3. `<%- code %>`：可解析html标签\n\n下面的例子解释了 `<% code %>` 的用法：\n\n**数据**\n\n```js\nsupplies: ['mop', 'broom', 'duster']\n```\n\n**模板**\n\n```ejs\n<ul>\n<% for(var i=0; i<supplies.length; i++) {%>\n   <li><%= supplies[i] %></li>\n<% } %>\n</ul>\n```\n\n**渲染结果**\n\n```html\n<ul>\n  <li>mop</li>\n  <li>broom</li>\n  <li>duster</li>\n</ul>\n```\n\n### includes 模板模块化\n\n**views/header.ejs**\n\n```html\n<!DOCTYPE html>\n<html>\n  <head>\n    <style type=\"text/css\">\n      body {padding: 50px;font: 14px \"Lucida Grande\", Helvetica, Arial, sans-serif;}\n    </style>\n  </head>\n  <body>\n```\n\n**views/footer.ejs**\n\n```html\n  </body>\n</html>\n```\n\n**views/users.ejs**\n\n```ejs\n<%- include('header') %>\n  <h1><%= name.toUpperCase() %></h1>\n  <p>hello, <%= name %></p>\n<%- include('footer') %>\n```\n\n我们将原来的 users.ejs 拆成出了 header.ejs 和 footer.ejs，并在 users.ejs 通过 ejs 内置的 include 方法引入，从而实现了跟以前一个模板文件相同的功能。\n\n> 小提示：拆分模板组件通常有两个好处：\n>\n> 1. 模板可复用，减少重复代码\n> 2. 主模板结构清晰\n\n> 注意：要用 `<%- include('header') %>` 而不是 `<%= include('header') %>`\n\n","id":27}]